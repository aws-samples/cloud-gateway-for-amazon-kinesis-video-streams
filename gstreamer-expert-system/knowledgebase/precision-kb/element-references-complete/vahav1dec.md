frames. Correspondingly, plugins generally offer a different GStreamer
element for each of these functions, so pipelines can be built to
accommodate any need.

For example, the `va` plugin from `gst-plugins-bad` offers the
`vah264dec`, `vah264dec`, `vahav1dec`, etc., and `vapostproc` elements
that allow hardware-accelerated decoding through VAAPI, upload of raw
video frames to GPU memory, download of GPU frames to system memory and
presentation of GPU frames, respectively.

It is important to distinguish between conventional GStreamer frames,
which reside in system memory, and frames generated by
hardware-accelerated APIs. The latter reside in GPU memory and cannot
be touched by GStreamer. They can usually be downloaded to system
memory and treated as conventional GStreamer frames when they are
mapped, but it is far more efficient to leave them in the GPU and
display them from there.

GStreamer needs to keep track of where these “hardware buffers” are
though, so conventional buffers still travel from element to
element. They look like regular buffers, but mapping their content is
frames. Correspondingly, plugins generally offer a different GStreamer
element for each of these functions, so pipelines can be built to
accommodate any need.

For example, the `va` plugin from `gst-plugins-bad` offers the
`vah264dec`, `vah264dec`, `vahav1dec`, etc., and `vapostproc` elements
that allow hardware-accelerated decoding through VAAPI, upload of raw
video frames to GPU memory, download of GPU frames to system memory and
presentation of GPU frames, respectively.

It is important to distinguish between conventional GStreamer frames,
which reside in system memory, and frames generated by
hardware-accelerated APIs. The latter reside in GPU memory and cannot
be touched by GStreamer. They can usually be downloaded to system
memory and treated as conventional GStreamer frames when they are
mapped, but it is far more efficient to leave them in the GPU and
display them from there.

GStreamer needs to keep track of where these “hardware buffers” are
though, so conventional buffers still travel from element to
element. They look like regular buffers, but mapping their content is

---

